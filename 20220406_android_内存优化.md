####内存优化

##### 内存分区
    方法区 存放类的信息，常量
    虚拟机栈 每一个线程对应一个栈，每一个在执行的方法代表一个栈帧
    Native方法栈 与虚拟机栈类似，只是栈里面是Native方法。
    程序计数器，记录了当前线程执行的尾椎
    堆 最需要关注的，内存泄露和内存抖动也是发生这个区域

| 区域 | 生命周期 | 线程共享 | 存放内容                         | 备注                    |
|---|---|------|------------------------------|---|
| 方法区 | 进程级别 | 是    | 类加载信息，运行时常量池，静态变量            | --                    |
|堆|进程级别| 是    | new 创建的对象                    | --                    |
|虚拟机栈|线程级别|否| 栈帧，栈帧又具体分为局部变量表，方法出口,操作数栈    | 局部变量表存放了基本数据类型，和对象引用。 |
|本地方法栈|线程级别|否| 与虚拟机栈类似，栈帧是本地方法              |与虚拟机栈类似|
|程序计数器|线程级别|否| 记录着当前线程执行到位置的行号，当线程恢复的时候继续执行 |--|

    虚拟机栈中存放的一系列的栈帧，每一个栈帧代表一个正在执行的方法。栈帧的大小在编译时期就已经确认了，
    主要包括一下内容：
    1>局部变量表，记录者方法的参数以及局部变量。
    2>操作数栈， 方法的执行的运算，参数或者局部变量入栈，计算结果出来之后在出栈。
    3>返回地址 方法执行完毕或者异常退出，回到调用该方法的位置，即返回地址

##### 内存抖动
    内存抖动是指短时间内，创建大量对象和又回收这些对象，造成频繁的调用GC。
    GC执行过程中会暂停进程活动的进行，频繁的调用GC会造成应用卡顿，甚至OOM。
    
    常出现的的场景View的onDraw方法 反复创建paint path这些对象。反复的拼接
    String，每一次拼接都是创建新的对象。以及Bitmap对象反复创建，销毁。

##### 内存泄露
    对于不能使用的内存，例如Activity已经调用onDestroy方法，但是还有其他变量引用
    造成Activity这种内存不能回收掉。

    主要有一下情况造成以上问题：

    1>静态变量或者单例持有Context,禁止传入Activity,可以使用Application代替，
        要么使用WeakReference<Activity>
    2>创建非静态匿名对象，例如在Activity中创建handler成员变量，该变量实际上是创建的
        Handler的匿名对象，如果有长时间的延迟Message，在消息队列中，由于Message长时间
        存在，一直持有Handler也就间接持有Activity。
    3>对于File,Cursor，以及IO流未关闭，也会造成内存泄露
    4> 对于属性动画如果在Activity的生命周期内未调用cancel，该动画也会一直持有Activity
        造成Activity无法回收
    5>未反注册监听器

##### 内存回收
    GC主要分为两个步骤，检测和回收
    1.检测主要有引数计数法和可达性分析法。可达性分析，是指一个对象如果无法最终到Root变量引用，就视为可回收的。
    可以作为Root变量的有静态变量，虚拟机栈中的变量，常量，JNI中的本地方法。
    2.GC回收步骤算法有一下几种
        1> 标记-清除 
        对于可回收的对象，执行清除工作，容易产生不连续的空间碎片
        2> 复制
        将内存一分为二，执行GC时候，将继续存活的对象复制到另一区域，现有区域进行clean。避免了空间碎片。
        3> 标记-整理 
        从根节点遍历，标记所有能继续存活的对象；清除所有可回收的对象；所有可以存活的对象整理到连续一片区域，
        虽然比较节省空间，也不产生碎片，但是效率较低。
        4>分代算法
        新生区，分为Eden区，survivor1区，survivor2区。这里采用复制的算法，eden区满的时候会调用MinorGC。
        活动举例：

        eden区满的时候触发MinorGC，将存活的对象的复制到survivor1区域，标记为to类型，若survivor1区不足的
        情况下，超出对象放置到老年区。survivor2区域标记为from类型并将eden区域clean。随后survivor1区与
        survivor2区交换标签类型。survivor1为from，survivor2区为to类型。
        eden区再次满的时候，触发MinorGC，将eden区和survior1区的存活对象，复制到survivor2区，并且清除
        eden区和survivor1区，若survivor2区不足的情况下，超出对象放置到老年区。survivor1区与survivor区
        交换类型之后，survivor1区为to类型，survivor2区为from类型。
        如此往复

        年老区，采用标记-整理的算法，年老区满的时候会调用FullGC，这个应该极力避免，因为FullGC会导致系统进程
        活动暂停，使应用卡顿。